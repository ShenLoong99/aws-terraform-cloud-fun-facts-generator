name: "Production Deployment"
on:
  push:
    branches: [ main ]
    paths:
      - "**.tf"
      - "lambda/**"
      - "frontend/**"
      - ".github/workflows/cd.yml"
      - 'scripts/**'
  workflow_dispatch:

jobs:
  # STEP A: Detect what changed
  changes:
    runs-on: ubuntu-latest
    outputs:
      infra: ${{ steps.filter.outputs.infra }}
      app: ${{ steps.filter.outputs.app }}
    steps:
      - uses: actions/checkout@v4
      - uses: dorny/paths-filter@v3
        id: filter
        with:
          filters: |
            infra:
              - '**.tf'
              - 'lambda/**'
            app:
              - 'frontend/**'
              - 'scripts/**'
              - '.github/workflows/cd.yml'

  # STEP B: Infrastructure Job
  terraform:
    needs: changes
    # Only run if Step A detected .tf or lambda changes
    if: needs.changes.outputs.infra == 'true'
    runs-on: ubuntu-latest
    environment: prod
    steps:
      - name: Wait for TFC Apply
        uses: binxio/tfe-run-wait-action@main
        with:
          action: wait
          token: ${{ secrets.TF_API_TOKEN }}
          organization: "my-terraform-aws-projects-2025"
          workspace: "AWS-Cloud-Fun-Facts-Generator"
          clone_url: ${GITHUB_SERVER_URL}/${GITHUB_REPOSITORY}.git
          commit_sha: ${{ github.sha }}
          branch: "main"

  # STEP C: Deployment & Health Check
  deploy:
    needs: [changes, terraform]
    # Standard Guard: Run if (app changed) OR (infra job finished successfully)
    if: |
      always() && 
      (needs.changes.outputs.app == 'true' || needs.terraform.result == 'success')
    runs-on: ubuntu-latest
    environment: prod
    permissions:
      id-token: write
      contents: read
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          cli_config_credentials_token: ${{ secrets.TF_API_TOKEN }}

      - name: Fetch Environment Variables
        id: vars
        run: |
          terraform init
          # These always fetch current state, so SITE_URL is never empty
          echo "BUCKET_NAME=$(terraform output -raw s3_bucket_id)" >> $GITHUB_ENV
          echo "DIST_ID=$(terraform output -raw cloudfront_distribution_id)" >> $GITHUB_ENV
          echo "API_URL=$(terraform output -raw api_invoke_url)" >> $GITHUB_ENV
          echo "AWS_REGION=$(terraform output -raw aws_region)" >> $GITHUB_ENV
          echo "SITE_URL=$(terraform output -raw cloudfront_url)" >> $GITHUB_ENV

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::871308866502:role/GitHubActionRole
          aws-region: ${{ env.AWS_REGION }}

      - name: Deploy and Invalidate
        run: |
          # Inject the API URL into the frontend code
          sed -i "s|\${api_url}|${{ env.API_URL }}/|g" ./frontend/index.html
          # Sync files
          aws s3 sync ./frontend/ s3://${{ env.BUCKET_NAME }} --delete
          # Clear cache
          aws cloudfront create-invalidation --distribution-id ${{ env.DIST_ID }} --paths "/*"

      - name: Run Health Check
        run: |
          chmod +x ./scripts/health-check.sh
          ./scripts/health-check.sh
        env:
          AWS_REGION: ${{ env.AWS_REGION }}
          SITE_URL: ${{ env.SITE_URL }}

      - name: Smoke Test Website
        # We use the always() successful logic from your other project
        # but add a small 'retry' loop directly in YAML for reliability.
        run: |
          echo "üåê Testing Website: ${{ env.SITE_URL }}"
          for i in {1..5}; do
            STATUS=$(curl -o /dev/null -s -w "%{http_code}" "https://${{ env.SITE_URL }}")
            if [ "$STATUS" -eq 200 ]; then
              echo "‚úÖ Website is live at https://${{ env.SITE_URL }}"
              exit 0
            fi
            echo "‚è≥ Status $STATUS - CloudFront might still be propagating. Retrying in 10s..."
            sleep 10
          done
          echo "‚ùå Website failed after 5 attempts."
          exit 1